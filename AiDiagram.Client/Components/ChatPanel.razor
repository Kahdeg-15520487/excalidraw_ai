@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="chat-container">
    <div class="chat-header">
        <h3>AI Chat</h3>
    </div>
    
    <div class="chat-messages" @ref="messagesContainer">
        @foreach (var message in messages)
        {
            <div class="message @(message.IsUser ? "user" : "assistant")">
                <div class="message-content">@message.Content</div>
            </div>
        }
    </div>
    
    <div class="chat-input">
        <textarea @bind="currentMessage" 
                  @bind:event="oninput"
                  @onkeydown="HandleKeyDown"
                  placeholder="Type a message..." 
                  rows="2"></textarea>
        <button @onclick="SendMessage" disabled="@(string.IsNullOrWhiteSpace(currentMessage) || isSending)">
            @if (isSending)
            {
                <span>...</span>
            }
            else
            {
                <span>Send</span>
            }
        </button>
    </div>
</div>

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    .chat-header {
        padding: 16px;
        border-bottom: 1px solid #e0e0e0;
        background: #fff;
    }

    .chat-header h3 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
        color: #333;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .message {
        max-width: 90%;
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 14px;
        line-height: 1.4;
    }

    .message.user {
        align-self: flex-end;
        background: #6366f1;
        color: white;
        border-bottom-right-radius: 4px;
    }

    .message.assistant {
        align-self: flex-start;
        background: #fff;
        color: #333;
        border: 1px solid #e0e0e0;
        border-bottom-left-radius: 4px;
    }

    .chat-input {
        padding: 12px;
        border-top: 1px solid #e0e0e0;
        background: #fff;
        display: flex;
        gap: 8px;
    }

    .chat-input textarea {
        flex: 1;
        padding: 10px 12px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        resize: none;
        font-size: 14px;
        font-family: inherit;
    }

    .chat-input textarea:focus {
        outline: none;
        border-color: #6366f1;
    }

    .chat-input button {
        padding: 10px 20px;
        background: #6366f1;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
    }

    .chat-input button:hover:not(:disabled) {
        background: #4f46e5;
    }

    .chat-input button:disabled {
        background: #c7c7c7;
        cursor: not-allowed;
    }
</style>

@code {
    private List<ChatMessage> messages = new();
    private string currentMessage = "";
    private bool isSending = false;
    private ElementReference messagesContainer;
    private HubConnection? hubConnection;
    private string sessionId = Guid.NewGuid().ToString();
    private const string ExcalidrawContainerId = "excalidraw-main";

    protected override async Task OnInitializedAsync()
    {
        // Initialize SignalR connection with session ID for sticky session support
        var hubUrl = Navigation.ToAbsoluteUri($"/diagramhub?sessionId={sessionId}");
        hubConnection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .WithAutomaticReconnect()
            .Build();

        hubConnection.On<string, string>("ReceiveMessage", (user, message) =>
        {
            messages.Add(new ChatMessage { Content = message, IsUser = false });
            InvokeAsync(StateHasChanged);
        });

        // Handle tool execution from the agent - RETURNS a result for blocking RPC
        hubConnection.On("ExecuteTool", async (string action, System.Text.Json.JsonElement data) =>
        {
            await JSRuntime.InvokeVoidAsync("console.log", "[ChatPanel] ExecuteTool received:", action, data.ToString());
            
            try
            {
                string? elementId = null;
                
                switch (action)
                {
                    case "addElement":
                        elementId = await JSRuntime.InvokeAsync<string>("ExcalidrawAPI.addElement", ExcalidrawContainerId, data);
                        break;
                    case "updateElement":
                        var updateElementId = data.GetProperty("elementId").GetString();
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.updateElement", ExcalidrawContainerId, updateElementId, data);
                        elementId = updateElementId;
                        break;
                    case "deleteElements":
                        var elementIds = data.GetProperty("elementIds");
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.deleteElements", ExcalidrawContainerId, elementIds);
                        break;
                    case "clearCanvas":
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.clearCanvas", ExcalidrawContainerId);
                        break;
                    case "getCanvasState":
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.getCanvasState", ExcalidrawContainerId);
                        break;
                    default:
                        await JSRuntime.InvokeVoidAsync("console.warn", $"[ChatPanel] Unknown action: {action}");
                        return new AiDiagram.Shared.ToolCallResult { Success = false, Error = $"Unknown action: {action}" };
                }
                
                await JSRuntime.InvokeVoidAsync("console.log", "[ChatPanel] Tool executed successfully, elementId:", elementId);
                return new AiDiagram.Shared.ToolCallResult { Success = true, ElementId = elementId };
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("console.error", "[ChatPanel] Tool execution failed:", ex.Message);
                return new AiDiagram.Shared.ToolCallResult { Success = false, Error = ex.Message };
            }
        });

        await hubConnection.StartAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isSending) return;

        var messageToSend = currentMessage.Trim();
        currentMessage = "";
        isSending = true;

        messages.Add(new ChatMessage { Content = messageToSend, IsUser = true });
        StateHasChanged();

        try
        {
            if (hubConnection is not null)
            {
                await hubConnection.SendAsync("SendMessage", "User", messageToSend);
            }
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessage { Content = $"Error: {ex.Message}", IsUser = false });
        }
        finally
        {
            isSending = false;
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    private class ChatMessage
    {
        public string Content { get; set; } = "";
        public bool IsUser { get; set; }
    }
}
