@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@using Markdig
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="chat-container">
    <div class="chat-header">
        <h3>AI Chat</h3>
    </div>
    
    <div class="chat-messages" @ref="messagesContainer">
        @foreach (var message in messages)
        {
            @if (message.IsToolCall)
            {
                <div class="message tool-call">
                    <div class="tool-call-header">
                        <span class="tool-icon">ðŸ”§</span>
                        <span class="tool-name">@message.ToolAction</span>
                    </div>
                    <div class="tool-call-content"><pre>@message.Content</pre></div>
                </div>
            }
            else
            {
                <div class="message @(message.IsUser ? "user" : "assistant")">
                    <div class="message-content">@((MarkupString)RenderMarkdown(message.Content))</div>
                </div>
            }
        }
    </div>
    
    <div class="chat-input">
        <textarea @bind="currentMessage" 
                  @bind:event="oninput"
                  @onkeydown="HandleKeyDown"
                  @onkeydown:preventDefault="shouldPreventDefault"
                  placeholder="Type a message..." 
                  rows="2"></textarea>
        <button @onclick="SendMessage" disabled="@(string.IsNullOrWhiteSpace(currentMessage) || isSending)">
            @if (isSending)
            {
                <span>...</span>
            }
            else
            {
                <span>Send</span>
            }
        </button>
    </div>
</div>

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: 100%;
    }

    .chat-header {
        padding: 16px;
        border-bottom: 1px solid #e0e0e0;
        background: #fff;
    }

    .chat-header h3 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
        color: #333;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .message {
        max-width: 90%;
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 14px;
        line-height: 1.4;
    }

    .message.user {
        align-self: flex-end;
        background: #6366f1;
        color: white;
        border-bottom-right-radius: 4px;
    }

    .message.assistant {
        align-self: flex-start;
        background: #fff;
        color: #333;
        border: 1px solid #e0e0e0;
        border-bottom-left-radius: 4px;
    }

    /* Markdown styles */
    .message-content p {
        margin: 0 0 8px 0;
    }
    .message-content p:last-child {
        margin-bottom: 0;
    }
    .message-content pre {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 12px;
        border-radius: 6px;
        overflow-x: auto;
        font-size: 13px;
        margin: 8px 0;
    }
    .message-content code {
        background: rgba(0,0,0,0.08);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 13px;
        font-family: 'Consolas', 'Monaco', monospace;
    }
    .message-content pre code {
        background: none;
        padding: 0;
    }
    .message.user .message-content code {
        background: rgba(255,255,255,0.2);
    }
    .message-content ul, .message-content ol {
        margin: 8px 0;
        padding-left: 20px;
    }
    .message-content li {
        margin: 4px 0;
    }

    /* Tool call styles */
    .message.tool-call {
        align-self: flex-start;
        background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        border: 1px solid #7dd3fc;
        border-left: 4px solid #0ea5e9;
        max-width: 95%;
    }
    .tool-call-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 6px;
    }
    .tool-icon {
        font-size: 14px;
    }
    .tool-name {
        font-weight: 600;
        color: #0369a1;
        font-size: 13px;
    }
    .tool-call-content pre {
        background: rgba(255,255,255,0.7);
        padding: 8px;
        border-radius: 4px;
        font-size: 12px;
        margin: 0;
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .chat-input {
        padding: 12px;
        border-top: 1px solid #e0e0e0;
        background: #fff;
        display: flex;
        gap: 8px;
    }

    .chat-input textarea {
        flex: 1;
        padding: 10px 12px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        resize: none;
        font-size: 14px;
        font-family: inherit;
    }

    .chat-input textarea:focus {
        outline: none;
        border-color: #6366f1;
    }

    .chat-input button {
        padding: 10px 20px;
        background: #6366f1;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
    }

    .chat-input button:hover:not(:disabled) {
        background: #4f46e5;
    }

    .chat-input button:disabled {
        background: #c7c7c7;
        cursor: not-allowed;
    }
</style>

@code {
    private List<ChatMessage> messages = new();
    private string currentMessage = "";
    private bool isSending = false;
    private bool shouldPreventDefault = false;
    private ElementReference messagesContainer;
    private HubConnection? hubConnection;
    private string sessionId = "";
    private const string ExcalidrawContainerId = "excalidraw-main";
    private const string SessionIdKey = "ai_diagram_session_id";

    protected override async Task OnInitializedAsync()
    {
        // Load or create session ID from localStorage for history persistence
        sessionId = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", SessionIdKey) ?? "";
        if (string.IsNullOrEmpty(sessionId))
        {
            sessionId = Guid.NewGuid().ToString();
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", SessionIdKey, sessionId);
        }
        
        // Initialize IndexedDB for chat history
        await JSRuntime.InvokeVoidAsync("ChatHistoryDB.init");
        
        // Load existing history from IndexedDB
        await LoadHistoryFromIndexedDB();
        
        // Initialize SignalR connection with session ID for sticky session support
        var hubUrl = Navigation.ToAbsoluteUri($"/diagramhub?sessionId={sessionId}");
        hubConnection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .WithAutomaticReconnect()
            .Build();

        hubConnection.On<string, string>("ReceiveMessage", async (user, message) =>
        {
            var chatMessage = new ChatMessage { Content = message, IsUser = false };
            messages.Add(chatMessage);
            await SaveMessageToIndexedDB(chatMessage);
            await InvokeAsync(StateHasChanged);
        });

        // Handle tool execution from the agent - RETURNS a result for blocking RPC
        hubConnection.On("ExecuteTool", async (string action, System.Text.Json.JsonElement data) =>
        {
            await JSRuntime.InvokeVoidAsync("console.log", "[ChatPanel] ExecuteTool received:", action, data.ToString());
            
            try
            {
                string? elementId = null;
                
                // Add tool call to chat messages
                var toolCallMessage = new ChatMessage 
                { 
                    IsToolCall = true, 
                    ToolAction = action,
                    Content = data.ToString()
                };
                messages.Add(toolCallMessage);
                await InvokeAsync(StateHasChanged);
                
                switch (action)
                {
                    case "addElement":
                        elementId = await JSRuntime.InvokeAsync<string>("ExcalidrawAPI.addElement", ExcalidrawContainerId, data);
                        break;
                    case "updateElement":
                        var updateElementId = data.GetProperty("elementId").GetString();
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.updateElement", ExcalidrawContainerId, updateElementId, data);
                        elementId = updateElementId;
                        break;
                    case "deleteElements":
                        var elementIds = data.GetProperty("elementIds");
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.deleteElements", ExcalidrawContainerId, elementIds);
                        break;
                    case "clearCanvas":
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.clearCanvas", ExcalidrawContainerId);
                        break;
                    case "getCanvasState":
                        var canvasState = await JSRuntime.InvokeAsync<object>("ExcalidrawAPI.getCanvasState", ExcalidrawContainerId);
                        await JSRuntime.InvokeVoidAsync("console.log", "[ChatPanel] Canvas state:", canvasState);
                        return new AiDiagram.Shared.ToolCallResult { Success = true, Data = canvasState };
                    default:
                        await JSRuntime.InvokeVoidAsync("console.warn", $"[ChatPanel] Unknown action: {action}");
                        return new AiDiagram.Shared.ToolCallResult { Success = false, Error = $"Unknown action: {action}" };
                }
                
                await JSRuntime.InvokeVoidAsync("console.log", "[ChatPanel] Tool executed successfully, elementId:", elementId);
                return new AiDiagram.Shared.ToolCallResult { Success = true, ElementId = elementId };
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("console.error", "[ChatPanel] Tool execution failed:", ex.Message);
                return new AiDiagram.Shared.ToolCallResult { Success = false, Error = ex.Message };
            }
        });

        await hubConnection.StartAsync();
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // Prevent Enter from adding newline when sending (but allow Shift+Enter for newlines)
        shouldPreventDefault = e.Key == "Enter" && !e.ShiftKey;
        
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isSending) return;

        var messageToSend = currentMessage.Trim();
        currentMessage = "";
        isSending = true;
        StateHasChanged(); // Clear input immediately

        var userMessage = new ChatMessage { Content = messageToSend, IsUser = true };
        messages.Add(userMessage);
        await SaveMessageToIndexedDB(userMessage);
        StateHasChanged();

        try
        {
            if (hubConnection is not null)
            {
                // Get history formatted for LLM from IndexedDB
                var history = await JSRuntime.InvokeAsync<System.Text.Json.JsonElement[]>("ChatHistoryDB.getHistoryForLLM", sessionId);
                await hubConnection.SendAsync("SendMessageWithHistory", "User", messageToSend, history);
            }
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessage { Content = $"Error: {ex.Message}", IsUser = false });
        }
        finally
        {
            isSending = false;
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    private async Task LoadHistoryFromIndexedDB()
    {
        try
        {
            var history = await JSRuntime.InvokeAsync<System.Text.Json.JsonElement[]>("ChatHistoryDB.getHistory", sessionId);
            foreach (var msg in history)
            {
                messages.Add(new ChatMessage
                {
                    Content = msg.GetProperty("content").GetString() ?? "",
                    IsUser = msg.GetProperty("isUser").GetBoolean(),
                    IsToolCall = msg.TryGetProperty("isToolCall", out var toolCall) && toolCall.GetBoolean(),
                    ToolAction = msg.TryGetProperty("toolAction", out var action) ? action.GetString() : null
                });
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.warn", "[ChatPanel] Failed to load history:", ex.Message);
        }
    }

    private async Task SaveMessageToIndexedDB(ChatMessage message)
    {
        try
        {
            var jsMessage = new { 
                content = message.Content, 
                isUser = message.IsUser,
                isToolCall = message.IsToolCall,
                toolAction = message.ToolAction
            };
            await JSRuntime.InvokeVoidAsync("ChatHistoryDB.saveMessage", sessionId, jsMessage);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.warn", "[ChatPanel] Failed to save message:", ex.Message);
        }
    }

    private class ChatMessage
    {
        public string Content { get; set; } = "";
        public bool IsUser { get; set; }
        public bool IsToolCall { get; set; }
        public string? ToolAction { get; set; }
    }

    private static readonly MarkdownPipeline _markdownPipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .DisableHtml()
        .Build();

    private string RenderMarkdown(string? content)
    {
        if (string.IsNullOrEmpty(content))
            return "";
        
        return Markdown.ToHtml(content, _markdownPipeline);
    }
}
