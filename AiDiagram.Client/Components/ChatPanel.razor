@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.JSInterop
@using Markdig
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="chat-layout">
    <div class="sessions-sidebar @(showSidebar ? "open" : "")">
        <div class="sidebar-header">
            <h3>History</h3>
            <button class="close-sidebar" @onclick="() => showSidebar = false">√ó</button>
        </div>
        <div class="sessions-list">
            @if (sessions.Count == 0)
            {
                <div class="no-sessions">
                    <span>No chat history found.</span>
                    <span style="font-size: 12px; opacity: 0.7;">Start a new chat to begin!</span>
                </div>
            }
            @foreach (var session in sessions)
            {
                <div class="session-item @(session.SessionId == sessionId ? "active" : "")">
                    <div class="session-info" @onclick="() => SwitchSession(session.SessionId)">
                        <div class="session-date">@session.LastMessage.ToLocalTime().ToString("MMM dd, HH:mm")</div>
                        <div class="session-preview">@(string.IsNullOrEmpty(session.Preview) ? "New Chat" : session.Preview)</div>
                    </div>
                    <button class="delete-session" @onclick="() => DeleteSession(session.SessionId)" @onclick:stopPropagation="true">üóëÔ∏è</button>
                </div>
            }
        </div>
    </div>

    <div class="chat-container">
        <div class="chat-header">
            <button class="menu-btn" @onclick="() => showSidebar = !showSidebar">‚ò∞</button>
            <h3>AI Chat</h3>
            <button class="new-chat-btn" @onclick="CreateNewSession" title="New Chat">+</button>
        </div>
        
        <div class="chat-messages" @ref="messagesContainer">
        @foreach (var message in messages)
        {
            @if (message.IsToolCall)
            {
                <div class="message tool-call">
                    <div class="tool-call-header">
                        <span class="tool-icon">üîß</span>
                        <span class="tool-name">@message.ToolAction</span>
                    </div>
                    <div class="tool-call-content"><pre>@message.Content</pre></div>
                </div>
            }
            else
            {
                <div class="message @(message.IsUser ? "user" : "assistant")">
                    <div class="message-content">@((MarkupString)RenderMarkdown(message.Content))</div>
                </div>
            }
        }
    </div>
    
    <div class="chat-input">
        <textarea @bind="currentMessage" 
                  @bind:event="oninput"
                  @onkeydown="HandleKeyDown"
                  @onkeydown:preventDefault="shouldPreventDefault"
                  placeholder="Type a message..." 
                  rows="2"></textarea>
        <button @onclick="SendMessage" disabled="@(string.IsNullOrWhiteSpace(currentMessage) || isSending)">
            @if (isSending)
            {
                <span>...</span>
            }
            else
            {
                <span>Send</span>
            }
        </button>
    </div>
</div>

</div>

<style>
    .chat-layout {
        display: flex;
        height: 100%;
        width: 100%;
        overflow: hidden;
        position: relative;
    }

    .sessions-sidebar {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 260px;
        background: #f8fafc;
        border-right: 1px solid #e2e8f0;
        display: flex;
        flex-direction: column;
        transition: transform 0.3s ease;
        z-index: 100;
        transform: translateX(-100%);
        box-shadow: 2px 0 8px rgba(0,0,0,0.1);
    }

    .sessions-sidebar.open {
        transform: translateX(0);
    }

    /* Mobile handling for sidebar - removed specific media query as it applies globally now */

    .sidebar-header {
        padding: 16px;
        border-bottom: 1px solid #e2e8f0;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .sidebar-header h3 {
        margin: 0;
        font-size: 16px;
        color: #334155;
    }

    .close-sidebar {
        background: none;
        border: none;
        font-size: 20px;
        color: #64748b;
        cursor: pointer;
        display: block;
    }
    /* Removed media query for close-sidebar */

    .sessions-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
    }

    .no-sessions {
        padding: 20px;
        text-align: center;
        color: #94a3b8;
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 14px;
        margin-top: 20px;
    }

    .session-item {
        display: flex;
        align-items: center;
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        margin-bottom: 4px;
        transition: background 0.2s;
    }

    .session-item:hover {
        background: #e2e8f0;
    }

    .session-item.active {
        background: #e0f2fe;
        border: 1px solid #bae6fd;
    }

    .session-info {
        flex: 1;
        overflow: hidden;
    }

    .session-date {
        font-size: 11px;
        color: #64748b;
        margin-bottom: 2px;
    }

    .session-preview {
        font-size: 13px;
        color: #334155;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .delete-session {
        background: none;
        border: none;
        opacity: 0;
        font-size: 12px;
        padding: 4px;
        cursor: pointer;
        transition: opacity 0.2s;
    }

    .session-item:hover .delete-session {
        opacity: 0.6;
    }
    
    .delete-session:hover {
        opacity: 1 !important;
    }

    .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        height: 100%;
        min-width: 0; /* Important for flex child truncation */
    }

    .chat-header {
        padding: 12px 16px;
        border-bottom: 1px solid #e0e0e0;
        background: #fff;
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .menu-btn {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #64748b;
        padding: 4px;
    }

    .new-chat-btn {
        margin-left: auto;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        background: #eff6ff;
        color: #3b82f6;
        border: 1px solid #dbeafe;
        font-size: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        padding-bottom: 2px;
    }

    .new-chat-btn:hover {
        background: #3b82f6;
        color: white;
    }

    .chat-header h3 {
        margin: 0;
        font-size: 16px;
        font-weight: 600;
        color: #333;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .message {
        max-width: 90%;
        padding: 10px 14px;
        border-radius: 12px;
        font-size: 14px;
        line-height: 1.4;
    }

    .message.user {
        align-self: flex-end;
        background: #6366f1;
        color: white;
        border-bottom-right-radius: 4px;
    }

    .message.assistant {
        align-self: flex-start;
        background: #fff;
        color: #333;
        border: 1px solid #e0e0e0;
        border-bottom-left-radius: 4px;
    }

    /* Markdown styles */
    .message-content p {
        margin: 0 0 8px 0;
    }
    .message-content p:last-child {
        margin-bottom: 0;
    }
    .message-content pre {
        background: #1e1e1e;
        color: #d4d4d4;
        padding: 12px;
        border-radius: 6px;
        overflow-x: auto;
        font-size: 13px;
        margin: 8px 0;
    }
    .message-content code {
        background: rgba(0,0,0,0.08);
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 13px;
        font-family: 'Consolas', 'Monaco', monospace;
    }
    .message-content pre code {
        background: none;
        padding: 0;
    }
    .message.user .message-content code {
        background: rgba(255,255,255,0.2);
    }
    .message-content ul, .message-content ol {
        margin: 8px 0;
        padding-left: 20px;
    }
    .message-content li {
        margin: 4px 0;
    }

    /* Tool call styles */
    .message.tool-call {
        align-self: flex-start;
        background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        border: 1px solid #7dd3fc;
        border-left: 4px solid #0ea5e9;
        max-width: 95%;
    }
    .tool-call-header {
        display: flex;
        align-items: center;
        gap: 8px;
        margin-bottom: 6px;
    }
    .tool-icon {
        font-size: 14px;
    }
    .tool-name {
        font-weight: 600;
        color: #0369a1;
        font-size: 13px;
    }
    .tool-call-content pre {
        background: rgba(255,255,255,0.7);
        padding: 8px;
        border-radius: 4px;
        font-size: 12px;
        margin: 0;
        overflow-x: auto;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .chat-input {
        padding: 12px;
        border-top: 1px solid #e0e0e0;
        background: #fff;
        display: flex;
        gap: 8px;
    }

    .chat-input textarea {
        flex: 1;
        padding: 10px 12px;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        resize: none;
        font-size: 14px;
        font-family: inherit;
    }

    .chat-input textarea:focus {
        outline: none;
        border-color: #6366f1;
    }

    .chat-input button {
        padding: 10px 20px;
        background: #6366f1;
        color: white;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
    }

    .chat-input button:hover:not(:disabled) {
        background: #4f46e5;
    }

    .chat-input button:disabled {
        background: #c7c7c7;
        cursor: not-allowed;
    }
</style>

@code {
    private List<ChatMessage> messages = new();
    private List<ChatSession> sessions = new();
    private string currentMessage = "";
    private bool isSending = false;
    private bool shouldPreventDefault = false;
    private bool showSidebar = false;
    private ElementReference messagesContainer;
    private HubConnection? hubConnection;
    private string sessionId = "";
    private const string ExcalidrawContainerId = "excalidraw-main";
    private const string SessionIdKey = "ai_diagram_session_id";

    protected override async Task OnInitializedAsync()
    {
        // Load or create session ID from localStorage for history persistence
        sessionId = await JSRuntime.InvokeAsync<string?>("localStorage.getItem", SessionIdKey) ?? "";
        if (string.IsNullOrEmpty(sessionId))
        {
            sessionId = Guid.NewGuid().ToString();
            await JSRuntime.InvokeVoidAsync("localStorage.setItem", SessionIdKey, sessionId);
        }
        
        // Initialize IndexedDB for chat history
        await JSRuntime.InvokeVoidAsync("ChatHistoryDB.init");
        
        // Load existing history and sessions
        await LoadSessions();
        await LoadHistoryFromIndexedDB();
        
        // Initialize SignalR connection with session ID for sticky session support
        await InitializeSignalR();
    }
    
    private async Task InitializeSignalR()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }

        var hubUrl = Navigation.ToAbsoluteUri($"/diagramhub?sessionId={sessionId}");
        hubConnection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .WithAutomaticReconnect()
            .Build();

        hubConnection.On<string, string>("ReceiveMessage", async (user, message) =>
        {
            var chatMessage = new ChatMessage { Content = message, IsUser = false };
            messages.Add(chatMessage);
            await SaveMessageToIndexedDB(chatMessage);
            await UpdateSessionList();
            await InvokeAsync(StateHasChanged);
        });

        // Handle tool execution from the agent - RETURNS a result for blocking RPC
        hubConnection.On("ExecuteTool", async (string action, System.Text.Json.JsonElement data) =>
        {
            // ... (existing tool execution logic, simplified for brevity, assume calling specific handler)
            return await HandleExecuteTool(action, data);
        });

        await hubConnection.StartAsync();
    }

    // Refactored tool handler to be callable
    private async Task<AiDiagram.Shared.ToolCallResult> HandleExecuteTool(string action, System.Text.Json.JsonElement data)
    {
            await JSRuntime.InvokeVoidAsync("console.log", "[ChatPanel] ExecuteTool received:", action, data.ToString());
            
            try
            {
                string? elementId = null;
                
                // Add tool call to chat messages
                var toolCallMessage = new ChatMessage 
                { 
                    IsToolCall = true, 
                    ToolAction = action,
                    Content = data.ToString()
                };
                messages.Add(toolCallMessage);
                await SaveMessageToIndexedDB(toolCallMessage); // Save tool calls too
                await InvokeAsync(StateHasChanged);
                
                switch (action)
                {
                    case "addElement":
                        elementId = await JSRuntime.InvokeAsync<string>("ExcalidrawAPI.addElement", ExcalidrawContainerId, data);
                        break;
                    case "updateElement":
                        var updateElementId = data.GetProperty("elementId").GetString();
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.updateElement", ExcalidrawContainerId, updateElementId, data);
                        elementId = updateElementId;
                        break;
                    case "deleteElements":
                        var elementIds = data.GetProperty("elementIds");
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.deleteElements", ExcalidrawContainerId, elementIds);
                        break;
                    case "clearCanvas":
                        await JSRuntime.InvokeVoidAsync("ExcalidrawAPI.clearCanvas", ExcalidrawContainerId);
                        break;
                    case "getCanvasState":
                        var canvasState = await JSRuntime.InvokeAsync<object>("ExcalidrawAPI.getCanvasState", ExcalidrawContainerId);
                        await JSRuntime.InvokeVoidAsync("console.log", "[ChatPanel] Canvas state:", canvasState);
                        return new AiDiagram.Shared.ToolCallResult { Success = true, Data = canvasState };
                    default:
                        await JSRuntime.InvokeVoidAsync("console.warn", $"[ChatPanel] Unknown action: {action}");
                        return new AiDiagram.Shared.ToolCallResult { Success = false, Error = $"Unknown action: {action}" };
                }
                
                await JSRuntime.InvokeVoidAsync("console.log", "[ChatPanel] Tool executed successfully, elementId:", elementId);
                return new AiDiagram.Shared.ToolCallResult { Success = true, ElementId = elementId };
            }
            catch (Exception ex)
            {
                await JSRuntime.InvokeVoidAsync("console.error", "[ChatPanel] Tool execution failed:", ex.Message);
                return new AiDiagram.Shared.ToolCallResult { Success = false, Error = ex.Message };
            }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        // Prevent Enter from adding newline when sending (but allow Shift+Enter for newlines)
        shouldPreventDefault = e.Key == "Enter" && !e.ShiftKey;
        
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            await SendMessage();
        }
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(currentMessage) || isSending) return;

        var messageToSend = currentMessage.Trim();
        currentMessage = "";
        isSending = true;
        StateHasChanged(); // Clear input immediately

        var userMessage = new ChatMessage { Content = messageToSend, IsUser = true };
        messages.Add(userMessage);
        await SaveMessageToIndexedDB(userMessage);
        await UpdateSessionList();
        StateHasChanged();

        try
        {
            if (hubConnection is not null)
            {
                // Get history formatted for LLM from IndexedDB
                var history = await JSRuntime.InvokeAsync<System.Text.Json.JsonElement[]>("ChatHistoryDB.getHistoryForLLM", sessionId);
                await hubConnection.SendAsync("SendMessageWithHistory", "User", messageToSend, history);
            }
        }
        catch (Exception ex)
        {
            messages.Add(new ChatMessage { Content = $"Error: {ex.Message}", IsUser = false });
        }
        finally
        {
            isSending = false;
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    private async Task LoadSessions()
    {
        sessions = new List<ChatSession>();
        try 
        {
            var rawSessions = await JSRuntime.InvokeAsync<System.Text.Json.JsonElement[]>("ChatHistoryDB.getAllSessions");
            await JSRuntime.InvokeVoidAsync("console.log", $"[ChatPanel] Loaded {rawSessions.Length} sessions");
            
            foreach (var s in rawSessions)
            {
                var session = new ChatSession
                {
                    SessionId = s.GetProperty("sessionId").GetString() ?? "",
                    MessageCount = s.GetProperty("messageCount").GetInt32(),
                    Preview = s.GetProperty("preview").GetString() ?? "",
                    LastMessage = DateTimeOffset.FromUnixTimeMilliseconds(s.GetProperty("lastMessage").GetInt64()).DateTime
                };
                sessions.Add(session);
            }
        }
        catch (Exception ex)
        {
             await JSRuntime.InvokeVoidAsync("console.warn", "[ChatPanel] Failed to load sessions:", ex.Message);
        }
        StateHasChanged();
    }
    
    // Just updates the list without full reload if possible, simple for now
    private async Task UpdateSessionList()
    {
        await LoadSessions();
    }

    private async Task SwitchSession(string newSessionId)
    {
        if (sessionId == newSessionId) return;
        
        sessionId = newSessionId;
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", SessionIdKey, sessionId);
        
        // Clear current messages and load new history
        messages.Clear();
        await LoadHistoryFromIndexedDB();
        
        // Reconnect SignalR with new session ID
        await InitializeSignalR();
        
        // Close sidebar on mobile
        if (showSidebar) showSidebar = false;
        
        StateHasChanged();
    }

    private async Task CreateNewSession()
    {
        var newSessionId = Guid.NewGuid().ToString();
        await SwitchSession(newSessionId);
    }

    private async Task DeleteSession(string sessionIdToDelete)
    {
        var confirmed = await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this chat?");
        if (!confirmed) return;
        
        await JSRuntime.InvokeVoidAsync("ChatHistoryDB.deleteSession", sessionIdToDelete);
        
        if (sessionId == sessionIdToDelete)
        {
            // If deleting current session, create a new one
            await CreateNewSession();
        }
        else
        {
            await LoadSessions();
            StateHasChanged();
        }
    }

    private async Task LoadHistoryFromIndexedDB()
    {
        try
        {
            var history = await JSRuntime.InvokeAsync<System.Text.Json.JsonElement[]>("ChatHistoryDB.getHistory", sessionId);
            foreach (var msg in history)
            {
                messages.Add(new ChatMessage
                {
                    Content = msg.GetProperty("content").GetString() ?? "",
                    IsUser = msg.GetProperty("isUser").GetBoolean(),
                    IsToolCall = msg.TryGetProperty("isToolCall", out var toolCall) && toolCall.GetBoolean(),
                    ToolAction = msg.TryGetProperty("toolAction", out var action) ? action.GetString() : null
                });
            }
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.warn", "[ChatPanel] Failed to load history:", ex.Message);
        }
    }

    private async Task SaveMessageToIndexedDB(ChatMessage message)
    {
        try
        {
            var jsMessage = new { 
                content = message.Content, 
                isUser = message.IsUser,
                isToolCall = message.IsToolCall,
                toolAction = message.ToolAction
            };
            await JSRuntime.InvokeVoidAsync("ChatHistoryDB.saveMessage", sessionId, jsMessage);
        }
        catch (Exception ex)
        {
            await JSRuntime.InvokeVoidAsync("console.warn", "[ChatPanel] Failed to save message:", ex.Message);
        }
    }

    private class ChatMessage
    {
        public string Content { get; set; } = "";
        public bool IsUser { get; set; }
        public bool IsToolCall { get; set; }
        public string? ToolAction { get; set; }
    }
    
    private class ChatSession
    {
        public string SessionId { get; set; } = "";
        public string Preview { get; set; } = "";
        public DateTime LastMessage { get; set; }
        public int MessageCount { get; set; }
    }

    private static readonly MarkdownPipeline _markdownPipeline = new MarkdownPipelineBuilder()
        .UseAdvancedExtensions()
        .DisableHtml()
        .Build();

    private string RenderMarkdown(string? content)
    {
        if (string.IsNullOrEmpty(content))
            return "";
        
        return Markdown.ToHtml(content, _markdownPipeline);
    }
}
